#!/bin/bash
# AIM - AI-Collaboration-Management Launcher
# Usage: aim [project_path] [command]

set -e

AIM_IMAGE="aim"
STATE_VOLUME="aim-state"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m'

AIM_DIR="$(cd "$(dirname "$0")" && pwd)"

show_help() {
    echo "AIM - AI-Collaboration-Management"
    echo ""
    echo "Usage:"
    echo "  aim init [--force] [project_path]  Initialize AIM workflow in a project"
    echo "  aim [project_path]                 Start AIM Docker shell for project"
    echo "  aim [project_path] claude          Start Claude Code inside AIM container"
    echo "  aim [project_path] validate        Validate branches"
    echo "  aim [project_path] watch           Watch for new branches"
    echo "  aim build                          Build/rebuild AIM image"
    echo "  aim status                         Show AIM status"
    echo "  aim help                           Show this help"
    echo ""
    echo "Examples:"
    echo "  aim init ~/my-project              Copy AIM workflow to project"
    echo "  aim init --force ~/my-project      Overwrite existing AIM files"
    echo "  aim /path/to/my-project            Start AIM on project"
    echo "  aim ~/my-project claude            Start Claude in AIM container"
    echo "  aim .                              Start AIM on current directory"
    echo "  aim                                Start AIM on current directory"
}

build_image() {
    echo -e "${BLUE}Building AIM Docker image...${NC}"
    docker build -t "$AIM_IMAGE" "$AIM_DIR"
    echo -e "${GREEN}AIM image built successfully${NC}"
}

init_project() {
    local force_mode=false
    local project_path="$1"

    # Check for --force flag
    if [[ "$1" == "--force" ]]; then
        force_mode=true
        project_path="$2"
    fi

    # Default to current directory if no path specified
    if [[ -z "$project_path" ]]; then
        project_path="$(pwd)"
    fi

    # Resolve to absolute path
    if [[ "$project_path" == "." ]]; then
        project_path="$(pwd)"
    elif [[ ! "$project_path" = /* ]]; then
        project_path="$(cd "$project_path" 2>/dev/null && pwd)"
    fi

    # Verify path exists
    if [[ ! -d "$project_path" ]]; then
        echo -e "${RED}Error: Project path not found: $project_path${NC}"
        exit 1
    fi

    local project_name=$(basename "$project_path")

    if [[ "$force_mode" == true ]]; then
        echo -e "${BLUE}Initializing AIM workflow in: ${project_name} (FORCE MODE - overwriting)${NC}"
    else
        echo -e "${BLUE}Initializing AIM workflow in: ${project_name}${NC}"
    fi
    echo ""

    # Create .claude directory
    if [[ ! -d "$project_path/.claude" ]] || [[ "$force_mode" == true ]]; then
        mkdir -p "$project_path/.claude/commands"
        echo -e "${GREEN}âœ“ Created .claude/ directory${NC}"
    else
        echo -e "${BLUE}â€¢ .claude/ already exists${NC}"
    fi

    # Copy settings.json with hooks
    if [[ ! -f "$project_path/.claude/settings.json" ]] || [[ "$force_mode" == true ]]; then
        cat > "$project_path/.claude/settings.json" << 'EOF'
{
  "$schema": "https://json.schemastore.org/claude-code-settings.json",
  "permissions": {
    "allow": [
      "Read", "Edit", "Write", "Glob", "Grep", "SlashCommand", "TodoWrite", "WebFetch", "WebSearch", "Task", "NotebookEdit", "BashOutput", "KillShell", "AskUserQuestion", "Skill", "ExitPlanMode", "Bash(git:*)", "Bash(wc:*)", "Bash(ls:*)", "Bash(rm:*)", "Bash(chmod:*)", "Bash(test:*)", "Bash(bash:*)", "Bash(./scripts/*)", "Bash(mkdir:*)", "Bash(cat:*)", "Bash(echo:*)", "Bash(ps:*)", "Bash(kill:*)", "Bash(pkill:*)", "Bash(sleep:*)", "Bash(find:*)", "Bash(grep:*)", "Bash(head:*)", "Bash(tail:*)", "Bash(sort:*)", "Bash(uniq:*)", "Bash(awk:*)", "Bash(sed:*)", "Bash(curl:*)", "Bash(wget:*)", "Bash(npm:*)", "Bash(yarn:*)", "Bash(pip:*)", "Bash(python:*)", "Bash(node:*)", "Bash(make:*)", "Bash(docker:*)", "Bash(xcode:*)", "Bash(open:*)", "Bash(pbcopy:*)", "Bash(pbpaste:*)", "Bash(defaults:*)", "Bash(osascript:*)", "Bash(afplay:*)", "Bash(./update-aicm.sh)", "Bash(./install.sh:*)", "Bash(source ~/.zshrc)", "Bash(./scripts/tcc-file-compliance.sh:*)", "Bash(./scripts/tcc-validate-branch.sh:*)", "Bash(./scripts/cleanup-watchers.sh:*)", "Bash(./scripts/aim-launcher.sh:*)", "Bash(xxd:*)", "Bash(aim-init:*)", "Bash(strace:*)", "Bash(timeout:*)", "SlashCommand(/works-ready)", "SlashCommand(/check-the-board)", "SlashCommand(/merge-to-main)", "SlashCommand(/verify)", "SlashCommand(/fix-violations)", "Read(//private/tmp/**)", "Bash(./scripts/:*)", "Bash(gh:*)", "Bash(./update-aicm.sh)", "Bash(./install.sh:*)", "Bash(source ~/.zshrc)", "Bash(./scripts/tcc-file-compliance.sh:*)", "Bash(./scripts/tcc-validate-branch.sh:*)", "Bash(bash:*)", "Bash(pkill:*)", "Bash(./scripts/cleanup-watchers.sh:*)", "Bash(./scripts/aim-launcher.sh:*)", "Bash(xxd:*)", "Bash(aim-init:*)", "Bash(chmod:*)", "Bash(git fetch:*)", "Bash(git checkout:*)", "Bash(test:*)", "Bash(git merge:*)", "Bash(git rev-parse:*)", "Bash(git push:*)", "Bash(git branch:*)", "Bash(git pull:*)", "Bash(git add:*)", "Bash(git commit:*)", "Bash(/tmp/branch-watcher-*.pid)", "Bash(/tmp/board-watcher-*.pid)", "Bash(git tag:*)", "Bash(recent-commits.txt)", "Bash(cat:*)", "Bash(git show:*)", "Bash(scripts/watch-branches.sh:*)", "Bash(scripts/watch-board.sh:*)", "Bash(/tmp/branch-watcher-*.state)", "Bash(kill:*)", "Bash(strace:*)", "Bash(timeout 3s cat:*)", "Bash(./scripts/watch-all.sh:*)", "Bash(./aim help:*)", "Bash(mv:*)"
    ]
  },
  "hooks": {
    "SessionStart": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/session-start.sh",
            "timeout": 10
          }
        ]
      }
    ],
    "UserPromptSubmit": [
      {
        "matcher": "^(wr|works ready)$",
        "hooks": [
          {
            "type": "command",
            "command": ".claude/hooks/works-ready-hook.sh",
            "timeout": 15
          }
        ]
      }
    ]
  }
}
EOF
        echo -e "${GREEN}âœ“ Created .claude/settings.json${NC}"
    else
        echo -e "${BLUE}â€¢ .claude/settings.json already exists (use --force to overwrite)${NC}"
    fi

    # Create hooks directory and hook files
    if [[ ! -d "$project_path/.claude/hooks" ]] || [[ "$force_mode" == true ]]; then
        mkdir -p "$project_path/.claude/hooks"
        echo -e "${GREEN}âœ“ Created .claude/hooks/ directory${NC}"
    else
        echo -e "${BLUE}â€¢ .claude/hooks/ already exists${NC}"
    fi

    # Create session-start.sh hook
    if [[ ! -f "$project_path/.claude/hooks/session-start.sh" ]] || [[ "$force_mode" == true ]]; then
        cat > "$project_path/.claude/hooks/session-start.sh" << 'EOF'
#!/bin/bash
# SessionStart hook - Displays startup context and launches monitoring

REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
REPO_NAME=$(basename "$REPO_ROOT" 2>/dev/null || echo "UNKNOWN")

cd "$REPO_ROOT" || exit 1

# Execute the session-start display script
"$REPO_ROOT/.claude/hooks/session-start-display.sh"
EOF
        chmod +x "$project_path/.claude/hooks/session-start.sh"
        echo -e "${GREEN}âœ“ Created .claude/hooks/session-start.sh${NC}"
    else
        echo -e "${BLUE}â€¢ .claude/hooks/session-start.sh already exists${NC}"
    fi

    # Create session-start-display.sh hook
    if [[ ! -f "$project_path/.claude/hooks/session-start-display.sh" ]] || [[ "$force_mode" == true ]]; then
        cat > "$project_path/.claude/hooks/session-start-display.sh" << 'EOF'
#!/bin/bash
# Session Start Display - Informative status for deployed AIM repos

# Colors for terminal output (to stderr)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
RESET='\033[0m'

REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
REPO_NAME=$(basename "$REPO_ROOT" 2>/dev/null || echo "UNKNOWN")
UNIFIED_WATCHER="$REPO_ROOT/scripts/watch-all.sh"
UNIFIED_PID_FILE="/tmp/aim-watcher-${REPO_NAME}.pid"
WATCHER_LOG="/tmp/aim-watcher-${REPO_NAME}.log"

cd "$REPO_ROOT" || exit 1

echo "" >&2
echo -e "${BOLD}${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}" >&2
echo -e "${BOLD}${CYAN}    AIM DEPLOYED REPOSITORY: $REPO_NAME${RESET}" >&2
echo -e "${BOLD}${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}" >&2

# Quick sync check
git fetch origin --quiet 2>/dev/null || true

# Check for OCC branches
OCC_BRANCHES=$(git branch -r 2>/dev/null | grep 'origin/claude/' | wc -l | xargs)

# Show branch status
if [ "$OCC_BRANCHES" -gt 0 ]; then
    echo -e "${YELLOW}ðŸ“‹ $OCC_BRANCHES OCC branch(es) found - use 'wr' to process${RESET}" >&2
    echo "SessionStart:startup hook success: FOUND_BRANCHES"
    echo "Status: $OCC_BRANCHES OCC branch(es) found"
    echo "Action: Use 'wr' or '/works-ready' to process"
else
    echo -e "${GREEN}âœ“ No pending OCC branches${RESET}" >&2
    echo "SessionStart:startup hook success: NO_BRANCHES"
    echo "Status: No pending OCC branches"
    echo "Action: Standing by"
fi

# Watcher management - check if watcher is already running
WATCHER_RUNNING=false
WATCHER_PID=""

if [ -f "$UNIFIED_PID_FILE" ]; then
    STORED_PID=$(cat "$UNIFIED_PID_FILE" 2>/dev/null)
    if [ -n "$STORED_PID" ] && ps -p "$STORED_PID" > /dev/null 2>&1; then
        WATCHER_RUNNING=true
        WATCHER_PID="$STORED_PID"
        echo -e "ðŸ“¡ AIM watcher ${GREEN}running${RESET} (background PID: $WATCHER_PID)" >&2
        echo "Watcher: RUNNING (PID: $WATCHER_PID)"
    fi
fi

# Start watcher if not running and script exists
if [ "$WATCHER_RUNNING" = false ]; then
    if [ -f "$UNIFIED_WATCHER" ] && [ -x "$UNIFIED_WATCHER" ]; then
        # Start watcher in background, fully detached
        nohup "$UNIFIED_WATCHER" > "$WATCHER_LOG" 2>&1 &
        NEW_PID=$!
        echo "$NEW_PID" > "$UNIFIED_PID_FILE"

        # Verify it actually started
        sleep 0.5
        if ps -p "$NEW_PID" > /dev/null 2>&1; then
            echo -e "ðŸ“¡ AIM watcher ${GREEN}started${RESET} (background PID: $NEW_PID)" >&2
            echo "Watcher: STARTED (PID: $NEW_PID)"
            echo "Logs: $WATCHER_LOG"
        else
            echo -e "${RED}âš ï¸  Watcher failed to start - check $WATCHER_LOG${RESET}" >&2
            echo "Watcher: FAILED TO START - check $WATCHER_LOG"
        fi
    elif [ -f "$UNIFIED_WATCHER" ]; then
        # Script exists but not executable
        chmod +x "$UNIFIED_WATCHER"
        nohup "$UNIFIED_WATCHER" > "$WATCHER_LOG" 2>&1 &
        NEW_PID=$!
        echo "$NEW_PID" > "$UNIFIED_PID_FILE"
        echo -e "ðŸ“¡ AIM watcher ${GREEN}started${RESET} (fixed permissions, PID: $NEW_PID)" >&2
        echo "Watcher: STARTED (fixed permissions, PID: $NEW_PID)"
    else
        echo -e "${YELLOW}âš ï¸  No watcher script at: $UNIFIED_WATCHER${RESET}" >&2
        echo "Watcher: NOT FOUND at $UNIFIED_WATCHER"
        echo "Fix: Run 'aim init --force' from AIM repo"
    fi
fi

echo -e "${BOLD}${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}" >&2
echo "" >&2
EOF
        chmod +x "$project_path/.claude/hooks/session-start-display.sh"
        echo -e "${GREEN}âœ“ Created .claude/hooks/session-start-display.sh${NC}"
    else
        echo -e "${BLUE}â€¢ .claude/hooks/session-start-display.sh already exists${NC}"
    fi

    # Create works-ready-hook.sh
    if [[ ! -f "$project_path/.claude/hooks/works-ready-hook.sh" ]] || [[ "$force_mode" == true ]]; then
        cat > "$project_path/.claude/hooks/works-ready-hook.sh" << 'EOF'
#!/bin/bash
# Works Ready Hook - AUTO-EXECUTES validation and merge

REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
REPO_NAME=$(basename "$REPO_ROOT")
PENDING_FILE="/tmp/branch-watcher-${REPO_NAME}.pending"

cd "$REPO_ROOT" 2>/dev/null || exit 0

# Find OCC branch to validate
BRANCH=""
if [ -f "$PENDING_FILE" ] && [ -s "$PENDING_FILE" ]; then
    BRANCH=$(head -1 "$PENDING_FILE" | awk '{print $1}')
fi

if [ -z "$BRANCH" ]; then
    # Check for remote OCC branches
    git fetch origin --quiet 2>/dev/null
    CURRENT=$(git branch --show-current)
    BRANCH=$(git branch -r | grep 'origin/claude/' | grep -v "origin/$CURRENT" | head -1 | sed 's/.*origin\///' | xargs)
fi

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "WORKS READY - AUTO-EXECUTE MODE"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

if [ -z "$BRANCH" ]; then
    echo "STATUS: No OCC branches found to merge."
    echo ""
    echo "INSTRUCTION: Report to user that there are no pending branches to validate."
    echo "Do NOT ask questions. Just report the status."
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    exit 0
fi

echo "INSTRUCTION: Execute /works-ready IMMEDIATELY for branch: $BRANCH"
echo "Do NOT ask questions. Just execute the slash command."
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
EOF
        chmod +x "$project_path/.claude/hooks/works-ready-hook.sh"
        echo -e "${GREEN}âœ“ Created .claude/hooks/works-ready-hook.sh${NC}"
    else
        echo -e "${BLUE}â€¢ .claude/hooks/works-ready-hook.sh already exists${NC}"
    fi

    # Create works-ready command
    if [[ ! -f "$project_path/.claude/commands/works-ready.md" ]] || [[ "$force_mode" == true ]]; then
        cat > "$project_path/.claude/commands/works-ready.md" << 'EOF'
---
description: TCC validates and merges OCC branch to main
---

**EXECUTE IMMEDIATELY. DO NOT ASK FOR CONFIRMATION.**

You are TCC. Complete these steps:

## Step 1: Check for pending branches

```bash
git fetch origin
git branch -r | grep "origin/claude/"
```

If no branches found, report "No pending branches" and stop.

## Step 2: Validate the branch

```bash
git checkout <branch-name>
```

- Check for obvious errors
- Verify files are reasonable size
- Run tests if available

## Step 3: Merge to main

```bash
git checkout main
git merge <branch-name>
git push origin main
```

## Step 4: Cleanup

```bash
git push origin --delete <branch-name>
git branch -D <branch-name>
```

## Step 5: Update board

Add completion record to docs/BOARD.md with commit hash.

## Report

```
âœ… MERGE COMPLETE
- Branch: [name] (deleted)
- Commit: [hash]
- Board: Updated
```
EOF
        echo -e "${GREEN}âœ“ Created .claude/commands/works-ready.md${NC}"
    else
        echo -e "${BLUE}â€¢ .claude/commands/works-ready.md already exists${NC}"
    fi

    # Create scripts directory and copy essential scripts
    if [[ ! -d "$project_path/scripts" ]] || [[ "$force_mode" == true ]]; then
        mkdir -p "$project_path/scripts"
        echo -e "${GREEN}âœ“ Created scripts/ directory${NC}"
    else
        echo -e "${BLUE}â€¢ scripts/ already exists${NC}"
    fi

    # Copy essential AIM scripts
    local scripts_to_copy=(
        "watch-all.sh"
        "tcc-validate-branch.sh"
        "tcc-file-compliance.sh"
        "cleanup-watchers.sh"
        "aim-launcher.sh"
    )

    # Create watcher status script
    if [[ ! -f "$project_path/scripts/watcher-status.sh" ]] || [[ "$force_mode" == true ]]; then
        cat > "$project_path/scripts/watcher-status.sh" << 'EOF'
#!/bin/bash
# Show AIM watcher status for deployed repos

REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
REPO_NAME=$(basename "$REPO_ROOT" 2>/dev/null || echo "UNKNOWN")
PID_FILE="/tmp/aim-watcher-${REPO_NAME}.pid"
LOG_FILE="/tmp/aim-watcher-${REPO_NAME}.log"

echo "AIM Watcher Status for $REPO_NAME:"
echo "================================"

if [ -f "$PID_FILE" ]; then
    PID=$(cat "$PID_FILE")
    if ps -p "$PID" > /dev/null 2>&1; then
        echo "âœ… Watcher is RUNNING (PID: $PID)"
        echo "ðŸ“‹ Log: $LOG_FILE"
        echo "ðŸ”— View: tail -f $LOG_FILE"
    else
        echo "âŒ Watcher process not found (stale PID file)"
        rm -f "$PID_FILE"
    fi
else
    echo "âŒ No watcher PID file found"
fi

echo ""
echo "Commands:"
echo "  ./scripts/watch-all.sh          - Start watcher (foreground)"
echo "  ./scripts/watcher-status.sh     - Show this status"
echo "  ./scripts/cleanup-watchers.sh   - Stop all watchers"
EOF
        chmod +x "$project_path/scripts/watcher-status.sh"
        echo -e "${GREEN}âœ“ Created scripts/watcher-status.sh${NC}"
    fi

    for script in "${scripts_to_copy[@]}"; do
        if [[ -f "$AIM_DIR/scripts/$script" ]]; then
            if [[ ! -f "$project_path/scripts/$script" ]] || [[ "$force_mode" == true ]]; then
                cp "$AIM_DIR/scripts/$script" "$project_path/scripts/"
                chmod +x "$project_path/scripts/$script"
                echo -e "${GREEN}âœ“ Copied scripts/$script${NC}"
            else
                echo -e "${BLUE}â€¢ scripts/$script already exists${NC}"
            fi
        fi
    done

    # Create docs directory and BOARD.md
    if [[ ! -d "$project_path/docs" ]] || [[ "$force_mode" == true ]]; then
        mkdir -p "$project_path/docs"
        echo -e "${GREEN}âœ“ Created docs/ directory${NC}"
    fi

    if [[ ! -f "$project_path/docs/BOARD.md" ]] || [[ "$force_mode" == true ]]; then
        cat > "$project_path/docs/BOARD.md" << EOF
# AIM Task Board - ${project_name}

## Tasks FOR OCC (TCC writes here, OCC reads)

*No pending OCC tasks*

## Tasks FOR TCC (OCC writes here, TCC reads)

*No pending TCC tasks*

---

**Board Status:** Initialized
**Project:** ${project_name}
**Created:** $(date +%Y-%m-%d)
EOF
        echo -e "${GREEN}âœ“ Created docs/BOARD.md${NC}"
    else
        echo -e "${BLUE}â€¢ docs/BOARD.md already exists${NC}"
    fi

    # Create CLAUDE.md
    if [[ ! -f "$project_path/CLAUDE.md" ]] || [[ "$force_mode" == true ]]; then
        cat > "$project_path/CLAUDE.md" << 'EOF'
# CLAUDE.md - AIM Workflow Instructions

**This file defines the TCC/OCC workflow for AI collaboration.**

---

## Roles

- **OCC** (Online Claude Code) = Developer
  - Writes code on feature branches (claude/*)
  - Commits and pushes to remote
  - Updates BOARD.md when work is ready for review

- **TCC** (Testing/Coordination Claude) = Project Manager
  - Validates OCC branches before merge
  - Runs tests and checks compliance
  - Merges validated work to main
  - Updates BOARD.md after completing tasks

---

## Workflow

1. **OCC** creates feature branch: `claude/feature-name-<session-id>`
2. **OCC** commits work and pushes to remote
3. **OCC** writes task to BOARD.md under "Tasks FOR TCC"
4. **TCC** validates the branch (tests, compliance)
5. **TCC** merges to main if valid, or posts issues to BOARD.md
6. **TCC** deletes merged branch and updates BOARD.md

---

## Board Location

Task board: `docs/BOARD.md`

---

## Session Start

When starting a session, check `docs/BOARD.md` for:
- Tasks assigned to your role
- Pending branches to process
- Status of recent work

---

## MANDATORY: Pattern Propagation Rule

**BEFORE fixing ANY pattern (paths, APIs, configs, names):**

### 1. COMPREHENSIVE SEARCH (MANDATORY)
```bash
grep -rn "<pattern>" --include="*.sh" --include="*.py" --include="*.swift" --include="*.md" .
```

### 2. SYSTEMATIC FIX (ALL OR NONE)
- List ALL files containing the pattern
- Fix ALL occurrences, never just the one encountered
- Test ALL affected functionality
- Update related documentation

### 3. SOURCE TEMPLATE CHECK (MANDATORY)
- If pattern came from `aim init`, fix the AIM framework source templates
- Prevent future propagation of the issue

### 4. VALIDATION (MANDATORY)
- Search again to confirm ZERO remaining instances
- Use `/fix-pattern` command for systematic approach

### Common Patterns Requiring Full Propagation:
- **Hardcoded paths:** `/home/user`, `/Users/`, `/Volumes/`
- **Project names:** Hardcoded references to specific projects
- **Absolute paths:** Should be relative with dynamic detection
- **API changes:** Endpoint updates, authentication changes
- **Config keys:** Renamed or restructured configuration

### Standard Path Detection (use in ALL shell scripts):
```bash
# Use relative paths - detect repo root from script location
REPO_ROOT="$(cd "$(dirname "$0")/../.." && pwd)"
```

**RULE: Partial fixes create technical debt. Fix the pattern completely or don't fix it at all.**
EOF
        echo -e "${GREEN}âœ“ Created CLAUDE.md${NC}"
    else
        echo -e "${BLUE}â€¢ CLAUDE.md already exists${NC}"
    fi

    # Add .claude/settings.json to .gitignore
    if [[ ! -f "$project_path/.gitignore" ]] || ! grep -q "\.claude/settings\.json" "$project_path/.gitignore"; then
        if [[ ! -f "$project_path/.gitignore" ]]; then
            touch "$project_path/.gitignore"
        fi
        echo -e "\n# Claude Code local settings (machine-specific)\n.claude/settings.json" >> "$project_path/.gitignore"
        echo -e "${GREEN}âœ“ Added .claude/settings.json to .gitignore${NC}"
    else
        echo -e "${BLUE}â€¢ .claude/settings.json already in .gitignore${NC}"
    fi

    echo ""
    echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${GREEN}AIM workflow initialized in: ${project_name}${NC}"
    echo -e "${GREEN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo "Files created:"
    echo "  â€¢ CLAUDE.md                           - AI role definitions"
    echo "  â€¢ .claude/settings.json               - Claude Code settings + hooks (gitignored)"
    echo "  â€¢ .claude/hooks/session-start.sh      - Session initialization hook"
    echo "  â€¢ .claude/hooks/session-start-display.sh - Startup status display"
    echo "  â€¢ .claude/hooks/works-ready-hook.sh   - Auto-execution hook"
    echo "  â€¢ .claude/commands/works-ready.md     - TCC merge command"
    echo "  â€¢ scripts/watch-all.sh                - Branch and board watcher"
    echo "  â€¢ scripts/watcher-status.sh           - Watcher status checker"
    echo "  â€¢ scripts/tcc-validate-branch.sh      - Branch validation"
    echo "  â€¢ scripts/tcc-file-compliance.sh      - File size compliance"
    echo "  â€¢ scripts/cleanup-watchers.sh         - Cleanup utilities"
    echo "  â€¢ docs/BOARD.md                       - Task tracking board"
    echo ""
    echo "Next steps:"
    echo "  1. cd $project_path"
    echo "  2. git add CLAUDE.md .claude/commands .claude/hooks scripts docs/BOARD.md .gitignore"
    echo "  3. git commit -m 'Add AIM workflow'"
    echo "  4. Start Claude Code session"
    echo ""
    echo "Or use Docker isolation:"
    echo "  aim $project_path"
    echo ""
}

show_status() {
    echo -e "${BLUE}AIM - AI-Collaboration-Management${NC}"
    echo ""
    echo "AIM Directory: $AIM_DIR"
    echo ""

    # Check Docker image
    if docker image inspect "$AIM_IMAGE" >/dev/null 2>&1; then
        echo -e "${GREEN}âœ“ Docker image 'aim' is built${NC}"
    else
        echo -e "${RED}âœ— Docker image not built. Run: aim build${NC}"
    fi

    # Check Docker running
    if docker info >/dev/null 2>&1; then
        echo -e "${GREEN}âœ“ Docker is running${NC}"
    else
        echo -e "${RED}âœ— Docker is not running${NC}"
    fi

    echo ""
}

run_aim() {
    local project_path="$1"
    local command="${2:-shell}"

    # Resolve to absolute path
    if [[ "$project_path" == "." ]]; then
        project_path="$(pwd)"
    elif [[ ! "$project_path" = /* ]]; then
        project_path="$(cd "$project_path" 2>/dev/null && pwd)"
    fi

    # Verify path exists
    if [[ ! -d "$project_path" ]]; then
        echo -e "${RED}Error: Project path not found: $project_path${NC}"
        exit 1
    fi

    # Check if image exists
    if ! docker image inspect "$AIM_IMAGE" >/dev/null 2>&1; then
        echo -e "${BLUE}AIM image not found. Building...${NC}"
        build_image
    fi

    # Handle claude command specifically
    if [[ "$command" == "claude" ]]; then
        echo -e "${BLUE}Starting Claude Code CLI in AIM container for: $(basename "$project_path")${NC}"
        docker run -it --rm \
            -v "$project_path":/project \
            -v "$STATE_VOLUME":/aim/state \
            "$AIM_IMAGE" bash -c "cd /project && claude"
    else
        # Run container with specified command
        docker run -it --rm \
            -v "$project_path":/project \
            -v "$STATE_VOLUME":/aim/state \
            "$AIM_IMAGE" "$command"
    fi
}

# Main
case "${1:-}" in
    help|--help|-h)
        show_help
        ;;
    build)
        build_image
        ;;
    init)
        if [[ "$2" == "--force" ]]; then
            init_project "--force" "${3:-$(pwd)}"
        elif [[ -z "$2" ]]; then
            init_project "$(pwd)"
        else
            init_project "$2"
        fi
        ;;
    status)
        show_status
        ;;
    "")
        run_aim "$(pwd)" "shell"
        ;;
    *)
        if [[ -d "$1" ]] || [[ "$1" == "." ]]; then
            run_aim "$1" "${2:-shell}"
        else
            # Assume it's a command for current directory
            run_aim "$(pwd)" "$1"
        fi
        ;;
esac
